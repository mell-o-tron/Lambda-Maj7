#use "./source/interpreter.ml";;

let a = LetIn(Decl(Var("bisection"), Atom(AnonFun(Var ("f"), Apply(FunExpr(LetIn(Decl(Var("aux"), Atom(AnonFun(Var ("limits"), LetIn(Decl(Var("a"), Apply(Nop(Elem), [Sym(Var("limits")) ; Atom(Int(0))])), LetIn(Decl(Var("b"), Apply(Nop(Elem), [Sym(Var("limits")) ; Atom(Int(1))])), LetIn(Decl(Var("i"), Apply(Nop(Elem), [Sym(Var("limits")) ; Atom(Int(2))])), LetIn(Decl(Var("center"), Apply(Nop(Div), [Apply(Nop(Add), [Sym(Var("a")) ; Sym(Var("b"))]) ; Atom(Float(2.0))])), IfThenElse(Apply(Nop(Greater), [Sym(Var("i")) ; Atom(Int(100))]), Sym(Var("center")), IfThenElse(Apply(Nop(Greater), [Apply(FunExpr(Sym(Var("f"))), [Sym(Var("center"))]) ; Atom(Float(0.0))]), Apply(FunExpr(Sym(Var("aux"))), [Atom(Tuple([Sym(Var("a")) ; Sym(Var("center")) ; Apply(Nop(Add), [Sym(Var("i")) ; Atom(Int(1))])]))]), Apply(FunExpr(Sym(Var("aux"))), [Atom(Tuple([Sym(Var("center")) ; Sym(Var("b")) ; Apply(Nop(Add), [Sym(Var("i")) ; Atom(Int(1))])]))])))))))))), Sym(Var("aux")))), [Atom(Tuple([Apply(Uop(Neg), [Atom(Float(1000.0))]) ; Atom(Float(1000.0)) ; Atom(Int(0))]))])))), LetIn(Decl(Var("sqrt"), Atom(AnonFun(Var ("x"), Apply(FunExpr(Sym(Var("bisection"))), [Atom(AnonFun(Var ("y"), Apply(Nop(Add), [Apply(Nop(Mul), [Sym(Var("y")) ; Sym(Var("y"))]) ; Apply(Uop(Neg), [Sym(Var("x"))])])))])))), LetIn(Decl(Var("PI"), Atom(Float(3.1415926535))), LetIn(Decl(Var("norm"), Atom(AnonFun(Var ("v"), Apply(FunExpr(Sym(Var("sqrt"))), [Apply(Nop(Add), [Apply(Nop(Mul), [Apply(Nop(Elem), [Sym(Var("v")) ; Atom(Int(0))]) ; Apply(Nop(Elem), [Sym(Var("v")) ; Atom(Int(0))])]) ; Apply(Nop(Mul), [Apply(Nop(Elem), [Sym(Var("v")) ; Atom(Int(1))]) ; Apply(Nop(Elem), [Sym(Var("v")) ; Atom(Int(1))])])])])))), Apply(FunExpr(Sym(Var("norm"))), [Atom(Tuple([Atom(Float(1.0)) ; Atom(Float(1.0))]))])))));;

let result = (eval emptyenv) a;;

print_simple_type result;;